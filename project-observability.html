<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Observability Framework | Nebat Taha Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;500&family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
</head>
<body>

    <nav>
        <div class="logo">NT</div>
        <ul>
            <li><a href="index.html">HOME</a></li>
            <li><a href="projects.html" style="color: var(--accent);">PROJECTS</a></li>
            <li><a href="assets/Nebat_Taha_Resume.pdf" class="nav-resume" target="_blank" download>RESUME</a></li>
        </ul>
    </nav>

   <article class="project-detail">
    <header>
        <a href="projects.html" class="back-link">‚Üê Back to Projects</a>
        <h1>Unified Observability & Custom Telemetry</h1>
        <p class="subtitle">Scaling monitoring across AWS and EKS while optimizing for long-term operational costs.</p>
        <div class="project-meta">
            <span class="tag">Prometheus</span>
            <span class="tag">Grafana Cloud</span>
            <span class="tag">Python (Boto3)</span>
            <span class="tag">Alertmanager</span>
        </div>
    </header>

    <section>
        <h2>01. The Decision: Why Prometheus vs. CloudWatch?</h2>
        <p>Before implementation, I conducted a deep-dive research into AWS-native vs. Open Source monitoring stacks. While CloudWatch offers seamless integration, the <strong>cost scaling</strong> for custom metrics and log-based alarms became a limiting factor for our high-throughput environment.</p>

        <div class="decision-box">
            <h3>Comparison Summary</h3>
            <table class="comparison-table">
                <tr>
                    <th>Metric</th>
                    <th>AWS CloudWatch</th>
                    <th>Prometheus + Grafana</th>
                </tr>
                <tr>
                    <td><strong>Cost</strong></td>
                    <td>Pay-per-metric/alarm (Scales linearly)</td>
                    <td>Managed via Grafana Cloud Free Tier (Fixed/Low)</td>
                </tr>
                <tr>
                    <td><strong>Querying</strong></td>
                    <td>CloudWatch Insights (SQL-like)</td>
                    <td>PromQL (Powerful for time-series math)</td>
                </tr>
                <tr>
                    <td><strong>Portability</strong></td>
                    <td>AWS Locked</td>
                    <td>Cloud-Agnostic / Multi-Cloud ready</td>
                </tr>
            </table>
        </div>
    </section>

    <section>
        <h2>02. Custom Python Metric Exporters</h2>
        <div class="decision-box">
            <h3>Solving the "Visibility Gap"</h3>
            <p>Standard exporters didn't cover our specific SQS queue depths and custom application health checks. I developed a <strong>Python-based Prometheus Exporter</strong> using <code>boto3</code> and <code>prometheus_client</code>. This service runs as a sidecar, translating AWS-specific metadata into Prometheus-readable formats.</p>
        </div>
        
    </section>

    <section>
        <h2>03. Multi-Cloud Alerting Architecture</h2>
        <div class="decision-box">
            <h3>Operational Goal: Deduplication & Alert Fatigue</h3>
            <p>Using <strong>Alertmanager</strong>, I implemented a grouping and silencing logic. Instead of receiving 50 individual emails for a regional outage, the system groups them into a single "Regional Critical" alert sent to Slack, significantly reducing <strong>Alert Fatigue</strong> for the on-call team.</p>
        </div>
    </section>
</article>

    <footer>
        <p>&copy; 2026 Nebat Taha | Built with code & coffee.</p>
    </footer>

</body>
</html>
